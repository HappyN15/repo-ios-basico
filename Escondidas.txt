enum RolesJuegoEscondidas {
    case contando
    case buscando_jugadores
    case buscando_escondite
    case escondido
    case regresando_a_base
    case encontrado
    case cantar_victoria
    case suspendido
}

/// Tipos de objetos m√°gicos
enum ObjetoMagicoTipo {
    case pocionInvisible
    case teleportador
    case detectorDeJugadores
    case amuletoProteccion
}

class ObjetoMagico {
    var nombre: String
    var tipo: ObjetoMagicoTipo
    var duracion: Int
    
    init(nombre: String, tipo: ObjetoMagicoTipo, duracion: Int) {
        self.nombre = nombre
        self.tipo = tipo
        self.duracion = duracion
    }
}

protocol JugadorDeEscondidas: AnyObject {
    var rol: RolesJuegoEscondidas { get set }
    var compa√±eros_de_juego: [JugadorDeEscondidas] { get set }
    var nombre: String { get set }
    var lugar_actual: UbicacionFisica? { get set }
    var visibilidad: Double { get set }
    var inventario: [ObjetoMagico] { get set }
    
    func actualizar() -> Bool
    func establecer_rol(_ rol_nuevo: RolesJuegoEscondidas) -> Bool
    func agregar_compa√±ero(_ compa√±ero_nuevo: JugadorDeEscondidas) -> Bool
    func usar_objeto()
}

extension JugadorDeEscondidas {
    func establecer_rol(_ rol_nuevo: RolesJuegoEscondidas) -> Bool {
        switch self.rol {
        case .suspendido:
            self.rol = rol_nuevo
            return true
        case .cantar_victoria, .encontrado:
            if rol_nuevo == .suspendido {
                self.rol = rol_nuevo
                return true
            }
            return false
        default:
            return false
        }
    }
}

struct Ubicacion2Dimensiones {
    var x: Int
    var y: Int
    init(_ x: Int, _ y: Int) {
        self.x = x
        self.y = y
    }
}

class UbicacionFisica {
    var nombre: String
    var lugares_cercanos: [UbicacionFisica]
    init(_ nombre: String) {
        self.nombre = nombre
        self.lugares_cercanos = []
    }
    func agregar_lugar(_ lugar: UbicacionFisica) -> Bool {
        for ubicacion in lugares_cercanos {
            if ubicacion.nombre == lugar.nombre {
                return false
            }
        }
        lugar.lugares_cercanos.append(self)
        self.lugares_cercanos.append(lugar)
        return true
    }
}

class Personaje {
    var nombre: String
    var ubicacion: UbicacionFisica?
    init(_ nombre: String) {
        self.nombre = nombre
        self.ubicacion = nil
    }
    func establecer_ubicacion(_ nueva_ubicacion: UbicacionFisica) -> Bool {
        if ubicacion == nil {
            self.ubicacion = nueva_ubicacion
            return true
        }
        if ubicacion!.nombre == nueva_ubicacion.nombre {
            return false
        }
        ubicacion = nueva_ubicacion
        return true
    }
}

class PersonajeJugable: Personaje, JugadorDeEscondidas {
    var visibilidad: Double
    var rol: RolesJuegoEscondidas = .suspendido
    var lugar_actual: UbicacionFisica?
    var numero_contado: Int
    var compa√±eros_de_juego: [JugadorDeEscondidas] = []
    var inventario: [ObjetoMagico] = []
    
    init(_ nombre: String, visibilidad: Double) {
        self.visibilidad = visibilidad
        self.numero_contado = 0
        super.init(nombre)
        self.lugar_actual = nil
    }
    
    func actualizar() -> Bool {
        usar_objeto()
        switch rol {
        case .contando:
            contar_para_buscar()
        case .buscando_jugadores:
            identificar_jugadores()
            moverse_de_lugar()
        case .buscando_escondite:
            moverse_de_lugar()
            let quedarse_quieto = Int.random(in: 0...10)
            if quedarse_quieto % 5 == 0 {
                rol = .escondido
            }
        case .cantar_victoria:
            print("üéâ \(nombre) canta victoria en \(lugar_actual?.nombre ?? "ning√∫n lugar")!")
        case .encontrado:
            print("\(nombre) ha sido encontrado y no puede moverse.")
        case .suspendido:
            print("Yo \(nombre) he perdido")
        case .regresando_a_base:
            print("\(nombre) est√° regresando a la base")
        }
        return false
    }
    
    func identificar_jugadores() {
        for compa√±ero in compa√±eros_de_juego {
            if compa√±ero.lugar_actual?.nombre == self.lugar_actual?.nombre {
                let probabilidad_de_omitir = Int(compa√±ero.visibilidad * 100)
                let suerte = Int.random(in: 0...100)
                if suerte > probabilidad_de_omitir {
                    compa√±ero.rol = .encontrado
                    print("üîç \(nombre) encontr√≥ a \(compa√±ero.nombre)!")
                }
            }
        }
    }
    
    func moverse_de_lugar() {
        guard let lugarActual = lugar_actual, !lugarActual.lugares_cercanos.isEmpty else { return }
        let indice = Int.random(in: 0..<lugarActual.lugares_cercanos.count)
        let nuevoLugar = lugarActual.lugares_cercanos[indice]
        let deberiaCambiar = Int.random(in: 0...10)
        if deberiaCambiar % 2 == 0 {
            cambiar_de_lugar_a(nuevoLugar)
        }
    }
    
    func contar_para_buscar() {
        numero_contado += 1
        print("Soy \(nombre) y voy en el \(numero_contado)")
        if numero_contado > 10 {
            rol = .buscando_jugadores
        }
    }
    
    func cambiar_de_lugar_a(_ ubicacion: UbicacionFisica) -> Bool {
        if lugar_actual == nil {
            lugar_actual = ubicacion
            return true
        }
        if ubicacion.nombre == lugar_actual?.nombre {
            return false
        }
        lugar_actual = ubicacion
        return true
    }
    
    func agregar_compa√±ero(_ compa√±ero_nuevo: JugadorDeEscondidas) -> Bool {
        if compa√±ero_nuevo.nombre == nombre { return false }
        if compa√±eros_de_juego.contains(where: { $0.nombre == compa√±ero_nuevo.nombre }) { return false }
        compa√±eros_de_juego.append(compa√±ero_nuevo)
        return true
    }
    
    func usar_objeto() {
        for (index, objeto) in inventario.enumerated().reversed() {
            switch objeto.tipo {
            case .pocionInvisible:
                print("‚ú® \(nombre) usa \(objeto.nombre) y se vuelve casi invisible!")
                visibilidad *= 0.3
            case .teleportador:
                if let destino = lugar_actual?.lugares_cercanos.randomElement() {
                    print("üåÄ \(nombre) usa el teleportador y aparece en \(destino.nombre)!")
                    cambiar_de_lugar_a(destino)
                }
            case .detectorDeJugadores:
                print("üîÆ \(nombre) usa el detector para sentir a los dem√°s jugadores cercanos.")
            case .amuletoProteccion:
                print("üõ°Ô∏è \(nombre) usa el amuleto de protecci√≥n, nadie puede encontrarlo por un turno.")
                visibilidad = 0.0
            }
            inventario.remove(at: index)
        }
    }
}

/// --- Inicializaci√≥n del mapa ---
let loby = UbicacionFisica("Loby")
let oficina = UbicacionFisica("Oficina")
let sala_de_estar = UbicacionFisica("Sala de estar")
let salon = UbicacionFisica("Salon")
let ba√±os = UbicacionFisica("Ba√±os")

loby.agregar_lugar(sala_de_estar)
loby.agregar_lugar(salon)
loby.agregar_lugar(oficina)
sala_de_estar.agregar_lugar(ba√±os)
salon.agregar_lugar(ba√±os)

/// --- Jugadores ---
var jugadores: [PersonajeJugable] = [
    PersonajeJugable("Pepito Bananas", visibilidad: 0.5),
    PersonajeJugable("Wally", visibilidad: 0.1),
    PersonajeJugable("Chuchito", visibilidad: 0.2),
    PersonajeJugable("Anabelle", visibilidad: 0.9),
    PersonajeJugable("Luc√≠a", visibilidad: 0.4), // nuevo jugador
    PersonajeJugable("El Mago", visibilidad: 0.7) // nuevo jugador especial
]

/// --- Asignar ubicaciones iniciales ---
for jugador in jugadores {
    jugador.cambiar_de_lugar_a(loby)
}

/// --- Asignar objetos m√°gicos a algunos jugadores ---
jugadores[0].inventario.append(ObjetoMagico(nombre: "Poci√≥n de Invisibilidad", tipo: .pocionInvisible, duracion: 2))
jugadores[4].inventario.append(ObjetoMagico(nombre: "Teleportador", tipo: .teleportador, duracion: 1))
jugadores[5].inventario.append(ObjetoMagico(nombre: "Detector de Jugadores", tipo: .detectorDeJugadores, duracion: 1))

/// --- Funci√≥n para iniciar el juego ---
func iniciar_juego(jugadores: [JugadorDeEscondidas]) {
    let numero_del_jugador_que_busca = Int.random(in: 0..<jugadores.count)
    let jugador_que_busca = jugadores[numero_del_jugador_que_busca]
    jugador_que_busca.establecer_rol(.contando)
    
    for jugador in jugadores {
        jugador_que_busca.agregar_compa√±ero(jugador)
        if jugador.rol == .suspendido {
            jugador.establecer_rol(.buscando_escondite)
        }
    }
}

/// --- Simulaci√≥n ---
iniciar_juego(jugadores: jugadores)

var ciclo_actual = 0
while true {
    for jugador in jugadores {
        jugador.actualizar()
    }
    for jugador in jugadores {
        print("El rol de \(jugador.nombre) es \(jugador.rol)")
        print("Ubicaci√≥n: \(jugador.lugar_actual?.nombre ?? "Desconocida")")
        print("Compa√±eros: \(jugador.compa√±eros_de_juego.count)")
        print("Inventario: \(jugador.inventario.map { $0.nombre }.joined(separator: ", "))")
    }
    print("")
    ciclo_actual += 1
    if ciclo_actual > 25 { break }
}
